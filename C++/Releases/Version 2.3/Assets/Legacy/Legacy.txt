// ---- ---- ---- ---- ---- ---- ---- ---- ---- Class Dependent Methods ---- ---- ---- ---- ---- ---- ---- ---- //
/*
* These methods require classes, structs, and their public variables in order to operate
*/
// Check Same Parameter In Hand Method - check_same_parameter_in_hand
/*
* This method determines if there is the same parameter present in a hand (Rank or Suit)
* This method takes in three parameters as input, A Hand object, a string, and an optional string
* This method returns a boolean value for if the check is true or false
*   - FuncInput(1): hand - Hand, this is the hand object that is fed into the function to check for a parameter type
*   - FuncInput(2): parameter - String, this is the string that is fed into the function to determine what is to be checked
*       - 'R' - When set to R, this function will check for there being the same rank in a hand
*       - 'S' - When set to S, this function will check for there being the same suit in a hand
*   - FuncInput(3): checking_parameter - String, optional parameter that may be checked for e.g. An Ace rank or a Clubs suit
*   - FuncOutput: result - Boolean, this boolean value tells the computer if the check is true or false
*/
bool check_same_parameter_in_hand(Hand& hand, const std::string parameter, const std::string checking_parameter = "")
{
    bool result = true;
    std::vector<Card> one_onward(hand.player.cards.begin() + 1, hand.player.cards.end());
    for (Card card : one_onward)
    {
        if (parameter == "R")
        {
            if (!check_card_parameter(card.card.rank, hand.player.cards.at(0).card.rank) || (!checking_parameter.empty() && !check_card_parameter(card.card.rank, checking_parameter)))
            {
                result = false;
                break;
            }
            else
            {
                continue;
            }
        }
        else if (parameter == "S")
        {
            if (!check_card_parameter(card.card.suit, hand.player.cards.at(0).card.suit) || (!checking_parameter.empty()) && !check_card_parameter(card.card.suit, checking_parameter))
            {
                result = false;
                break;
            }
            else
            {
                continue;
            }
        }
        else
        {
            std::cout << std::endl << color_text(31, "Invalid Parameter") + ". Please select either rank or suit to check." << std::endl; 
        }
    }
    return result;
}
// Check For Blackjack Method - check_blackjack
/*
* This method checks for if there is a Blackjack present in a players hand
* This method takes in a Hand object as an input and returns a boolean value in return
*   - FuncInput(1): hand - Hand, the hand that is being checked for if there is a Blackjack
*   - FuncOutput: result - Boolean, the boolean value that tells the user if a Blackjack is present
*/
bool check_blackjack(Hand& hand)
{
    bool result = false;
    for (Card card : hand.player.cards)
    {
        if (card.card.card_value == 10)
        {
            if (check_parameter_in_hand(hand, "R", "Ace"))
            {
                result = true;
            }
            else
            {
                continue;
            }
        }
        else
        {
            continue;
        }
    }
    return result;
}
// Update Game Statistics Method - update_stats
/*
* This method updates the game statistics for a player
* This method takes in a Hand object as an input and returns a hand object
*   - FuncInput(1): hand - Hand, this is the hand object that is being modified
*       - The following vectors are having values appended to them
*           - player.hand_bank_totals
*           - player.hand_wagers
*           - player.hand_nets
*           - player.hand_card_totals
*           - player.hand_hands_played
*   - FuncOutput: Hand - Hand, hand object that possesses all the attributes of a regular hand object
* This method should be implemented in the hand_comparison method
*/
Hand update_stats(Hand& hand)
{
    hand.player.hands_played += 1;
    hand.player.hand_hands_played.push_back(hand.player.hands_played);
    hand.player.hand_wagers.push_back(hand.player.wager);
    hand.player.hand_nets.push_back(hand.player.net);
    hand.player.hand_card_totals.push_back(hand.player.cards_total);
    hand.player.hand_bank_totals.push_back(hand.player.bank_total);
    return hand;
}
// Create CSV Statistics File Method - csv_stats
/*
* This method is designed to create a csv file that contains all of the trackable statistics in a Blackjack game
* This method creates a CSV File for the following statistics 
*   - Hand Number: This is the hand number that a player played
*   - Wager: This is the wager that is placed on a specific hand
*   - Net: This is the net profit / loss for a hand of a player
*   - Cards Total: This is the final hand value for a hand of a player
*   - Updated Bank: This is the updated bank total after a hand has finished for a player
* This method takes in a hand object and returns no value, but creates a CSV file
*   FuncInput(1): hand - Hand, this is the hand object that will have the statistics of the game tracked an made into a csv file
*/
void csv_stats(Hand& hand)
{
    std::string csvFileName = hand.player.name + " Results.csv";
    std::ofstream file(csvFileName);
    if (file)
    {
        file << "Hand Number, Wager, Net, Cards Total, Updated Bank" << std::endl;
        for (int i = 0; i < hand.player.hand_hands_played.size(); i++)
        {
            file << hand.player.hand_hands_played.at(i) << "," << hand.player.hand_wagers.at(i) << "," << hand.player.hand_nets.at(i)
            << "," << hand.player.hand_card_totals.at(i) << "," << hand.player.hand_bank_totals.at(i) << std::endl;
        }
        file.close();
        std::cout << "CSV File Created: " << csvFileName << std::endl; 
    }
    else if (!file)
    {
        std::cout << "Error creating CSV File: " << csvFileName << std::endl; 
    }
    else {}
}
// Special Options Method - special_options
Hand special_options(Hand& playerHand, Hand& dealerHand, bool override)
{
    override = false;
    if (playerHand.player.bank_total >= 0.5 * playerHand.player.wager) 
    {
        if (check_card_parameter(dealerHand.player.cards.back().card.rank, "Ace")) 
        {
            playerHand.player.can_buy_insurance = true;
        }
        else if (!check_card_parameter(dealerHand.player.cards.back().card.rank, "Ace"))
        {
            playerHand.player.can_buy_insurance = false;
        }
        else {}
        if (playerHand.player.bank_total >= playerHand.player.wager) 
        {
            playerHand.player.can_double_down = true;
            if (check_same_parameter_in_hand(playerHand,"R")) {
                if (!override)
                {
                    playerHand.player.can_split_hand = true;
                }
                else if (override) {
                    playerHand.player.can_split_hand = false;
                }
                else {}
            }
            else if (!check_same_parameter_in_hand(playerHand,"R")) {
                playerHand.player.can_split_hand = false;
            }
            else {}
        }
        else if (playerHand.player.bank_total < playerHand.player.wager) 
        {
            playerHand.player.can_double_down = false;
            playerHand.player.can_split_hand = false;
        }
        else {}
    }
    else if (playerHand.player.bank_total < 0.5 * playerHand.player.wager) {
        playerHand.player.can_buy_insurance = false;
        playerHand.player.can_double_down = false;
        playerHand.player.can_split_hand = false;
    }
    else {}
    return playerHand;
}
// Deal Hand To Players Method - deal_hand
/*
* This method deals the hands to players
* This method also checks if a player can double down, split their hand, and buy insurance
* This method takes in three separate parameters for inputs and returns the modified objects
*   - FuncInput(1): playerHand - Hand, this is the hand object for a user
*   - FuncInput(2): dealerHand - Hand, this is the hand object for a dealer
*   - FuncInput(3): shoe - Shoe, this is the shoe object that is being used for the game
*   - FuncOutput(1): playerHand - Hand, modified user hand object
*   - FuncOutput(2): dealerHand - Hand, modified dealer hand object
*   - FuncOutput(3): shoe - Shoe, modified shoe object being used in game
*/
std::tuple<Hand, Hand, Shoe> deal_hand(Hand& playerHand, Hand& dealerHand, Shoe& shoe)
{
    playerHand.Place_Wager();
    for (int i = 0; i < 4; i++)
    {
        if (i % 2 == 0)
        {
            playerHand.Hit(shoe);
        }
        else if (i % 2 == 1)
        {
            dealerHand.Hit(shoe);
        }
        else {}
    }
    std::cout << std::endl << "Here are the initial hands of each player: " << std::endl; 
    playerHand.Show_Hand("initial");
    dealerHand.Show_Hand("initial","");
    special_options(playerHand, dealerHand, false);
    return std::make_tuple(playerHand, dealerHand, shoe);
}
// Blackjack Strategy Method - blackjack_strategy
/*
* This method tells the user what they should do depending on Blackjack strategy
* This method uses the strategy outlined in the Assets folder of this projects version home directory
* This method takes in two Hand objects for input parameters and a boolean value for an over ride, it does not return a value
*   - FuncInput(1): playerHand - Hand, hand object for the user
*   - FuncInput(2): dealerHand - Hand, hand object that represents the dealer
*   - FuncInput(3): override - Boolean, this is a boolean value that will over ride a players ability to be recommended to split a hand
*       - This is only set to true if we are examining a hand that has already been split
*/
void blackjack_strategy(Hand& playerHand, Hand& dealerHand, bool override)
{
    std::string BlackJack = color_text(32, "Blackjack");
    std::string ShouldDD = color_text(31, "double down");
    std::string ShouldHit = color_text(31, "hit");
    std::string ShouldStand = color_text(31, "stand");
    std::string ShouldSplit = color_text(31, "split");
    special_options(playerHand, dealerHand, override);
    if (playerHand.player.cards.size() == 2 && (check_parameter_in_hand(playerHand, "R", "Ace") || check_same_parameter_in_hand(playerHand, "R")) && !check_blackjack(playerHand))
    {
        if (check_parameter_in_hand(playerHand, "R", "Ace") && (check_parameter_in_hand(playerHand, "R", "2") || check_parameter_in_hand(playerHand, "R", "3")))
        {
            switch (dealerHand.player.cards[1].card.card_value)
            {
            case 2:
            case 3:
            case 4:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 1:
                std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                break;
            case 5:
            case 6:
                if (playerHand.player.can_double_down && !playerHand.player.has_hit)
                {
                    std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldDD << " or " << ShouldHit << "." << std::endl;
                }
                else if (!playerHand.player.can_double_down || playerHand.player.has_hit)
                {
                    std::cout << std::endl << BlackJack << " strategy suggess " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                }
                else {}
                break;
            default:
                break;
            }
        }
        else if (check_parameter_in_hand(playerHand, "R", "Ace") && (check_parameter_in_hand(playerHand, "R", "4") || check_parameter_in_hand(playerHand, "R", "5")))
        {
            switch (dealerHand.player.cards[1].card.card_value)
            {
            case 2:
            case 3:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 1:
                std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                break;
            case 4:
            case 5:
            case 6:
                if (playerHand.player.can_double_down && !playerHand.player.has_hit)
                {
                    std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldDD << " or " << ShouldHit << "." << std::endl;
                }
                else if (!playerHand.player.can_double_down || playerHand.player.has_hit)
                {
                    std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                }
                else {}
                break;
            default:
                break;
            }
        }
        else if (check_parameter_in_hand(playerHand, "R", "Ace") && check_parameter_in_hand(playerHand, "R", "6"))
        {
            switch (dealerHand.player.cards[1].card.card_value)
            {
            case 2:
                std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                break;
            case 3:
            case 4:
            case 5:
            case 6:
                if (playerHand.player.can_double_down && !playerHand.player.has_hit)
                {
                    std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldDD << " or " << ShouldHit << "." << std::endl;
                }
                else if (!playerHand.player.can_double_down || playerHand.player.has_hit)
                {
                    std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                }
                else {}
                break;
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 1:
                std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                break;
            default:
                break;
            }
        }
        else if (check_parameter_in_hand(playerHand, "R", "Ace") && check_parameter_in_hand(playerHand, "R", "7"))
        {
            switch (dealerHand.player.cards[1].card.card_value)
            {
            case 2:
                std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldStand << "." << std::endl;
                break;
            case 3:
            case 4:
            case 5:
            case 6:
                if (playerHand.player.can_double_down && !playerHand.player.has_hit)
                {
                    std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldDD << " or " << ShouldStand << "." << std::endl;
                }
                else if (!playerHand.player.can_double_down || playerHand.player.has_hit)
                {
                    std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldStand << "." << std::endl;
                }
                else {}
                break;
            case 7:
            case 8:
                std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldStand << "." << std::endl;
                break;
            case 9:
            case 10:
            case 11:
            case 1:
                std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                break;
            default:
                break;
            }
        }
        else if (check_parameter_in_hand(playerHand, "R", "Ace") && (check_parameter_in_hand(playerHand, "R", "8") || check_parameter_in_hand(playerHand, "R", "9")))
        {
            std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldStand << "." << std::endl;
        }
        else {}
        if (check_same_parameter_in_hand(playerHand, "R"))
        {
            if (check_parameter_in_hand(playerHand, "R", "2") || check_parameter_in_hand(playerHand, "R", "3"))
            {
                switch (dealerHand.player.cards[1].card.card_value)
                {
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    if (playerHand.player.can_split_hand && (!playerHand.player.split_decision && !playerHand.player.chose_split_hand))
                    {
                        std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldSplit << " or " << ShouldHit << "." << std::endl;
                    }
                    else if (!playerHand.player.can_split_hand || (playerHand.player.split_decision && !playerHand.player.chose_split_hand))
                    {
                        std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                    }
                    else {}
                    break;
                case 8:
                case 9:
                case 10:
                case 11:
                case 1:
                    std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                    break;
                default:
                    break;
                }
            }
            else if (check_parameter_in_hand(playerHand, "R", "4"))
            {
                switch (dealerHand.player.cards[1].card.card_value)
                {
                case 2:
                case 3:
                case 4:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 1:
                    std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                    break;
                case 5:
                case 6:
                    if (playerHand.player.can_split_hand && (!playerHand.player.split_decision && !playerHand.player.chose_split_hand))
                    {
                        std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldSplit << " or " << ShouldHit << "." << std::endl;
                    }
                    else if (!playerHand.player.can_split_hand || (playerHand.player.split_decision && !playerHand.player.chose_split_hand))
                    {
                        std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                    }
                    else {}
                    break;
                default:
                    break;
                }
            }
            else if (check_parameter_in_hand(playerHand, "R", "5"))
            {
                switch (dealerHand.player.cards[1].card.card_value)
                {
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                    if (playerHand.player.can_double_down && !playerHand.player.has_hit)
                    {
                        std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldDD << " or " << ShouldHit << "." << std::endl;
                    }
                    else if (!playerHand.player.can_double_down) 
                    {
                        std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                    }
                    break;
                case 10:
                case 11:
                case 1:
                    std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                    break;
                default:
                    break;
                }
            }
            else if (check_parameter_in_hand(playerHand, "R", "6"))
            {
                if (playerHand.player.can_split_hand && (!playerHand.player.split_decision && !playerHand.player.chose_split_hand))
                {
                    switch (dealerHand.player.cards[1].card.card_value)
                    {
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldSplit << "." << std::endl;
                        break;
                    case 7:
                        std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldSplit << " or " << ShouldStand << "." << std::endl;
                        break;
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 1:
                        std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                        break;
                    default:
                        break;
                    }
                }
                else if (!playerHand.player.can_split_hand || (playerHand.player.split_decision && !playerHand.player.chose_split_hand))
                {
                    switch (dealerHand.player.cards[1].card.card_value)
                    {
                    case 2:
                    case 3:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 1:
                        std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                        break;
                    case 4:
                    case 5:
                    case 6:
                        std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldStand << "." << std::endl;
                        break;
                    default:
                        break;
                    }
                }
                else {}
            }
            else if (check_parameter_in_hand(playerHand, "R", "7"))
            {
                if (playerHand.player.can_split_hand && (!playerHand.player.split_decision && !playerHand.player.chose_split_hand))
                {
                    switch (dealerHand.player.cards[1].card.card_value)
                    {
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldSplit << "." << std::endl;
                        break;
                    case 8:
                        std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldSplit << " or " << ShouldHit << "." << std::endl;
                        break;
                    case 9:
                    case 10:
                    case 11:
                    case 1:
                        std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                        break;
                    default:
                        break;
                    }
                }
                else if (!playerHand.player.can_split_hand || (playerHand.player.split_decision && !playerHand.player.chose_split_hand))
                {
                    switch (dealerHand.player.cards[1].card.card_value)
                    {
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldStand << "." << std::endl;
                        break;
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 1:
                        std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                        break;
                    default:
                        break;
                    }
                }
                else {}
            }
            else if (check_parameter_in_hand(playerHand, "R", "8"))
            {
                if (playerHand.player.can_split_hand && (!playerHand.player.split_decision && !playerHand.player.chose_split_hand))
                {
                    std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldSplit << "." << std::endl;
                }
                else if (!playerHand.player.can_split_hand || (playerHand.player.split_decision && !playerHand.player.chose_split_hand))
                {
                    switch (dealerHand.player.cards[1].card.card_value)
                    {
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldStand << "." << std::endl;
                        break;
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 1:
                        std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                        break;
                    default:
                        break;
                    }
                }
                else {}
            }
            else if (check_parameter_in_hand(playerHand, "R", "9"))
            {
                if (playerHand.player.can_split_hand && (!playerHand.player.split_decision && !playerHand.player.chose_split_hand))
                {
                    switch (dealerHand.player.cards[1].card.card_value)
                    {
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 8:
                    case 9:
                        std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldSplit << "." << std::endl;
                        break;
                    case 7:
                    case 10:
                    case 11:
                    case 1:
                        std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldStand << "." << std::endl;
                        break;
                    default:
                        break;
                    }
                }
                else if (!playerHand.player.can_split_hand || (playerHand.player.split_decision && !playerHand.player.chose_split_hand))
                {
                    std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldStand << "." << std::endl;
                }
                else {}
            }
            else if (playerHand.player.cards_total == 20)
            {
                std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldStand << "." << std::endl;
            }
            else if (check_parameter_in_hand(playerHand, "R", "Ace"))
            {
                if (playerHand.player.can_split_hand && (!playerHand.player.split_decision && !playerHand.player.chose_split_hand))
                {
                    std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldSplit << "." << std::endl;
                }
                else if (!playerHand.player.can_split_hand || (playerHand.player.split_decision && !playerHand.player.chose_split_hand))
                {
                    switch (dealerHand.player.cards[1].card.card_value)
                    {
                    case 2:
                    case 3:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 1:
                        std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                        break;
                    case 4:
                    case 5:
                    case 6:
                        std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldStand << "." << std::endl;
                        break;
                    default:
                        break;
                    }
                }
                else {}
            }
            else {}
        }
        else {}
    }
    else if (playerHand.player.cards.size() >= 2)
    {
        if (playerHand.player.cards_total >= 4 && playerHand.player.cards_total <= 8)
        {
            std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
        }
        else if (playerHand.player.cards_total == 9)
        {
            switch (dealerHand.player.cards[1].card.card_value)
            {
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
                if (playerHand.player.cards.size() == 2 && playerHand.player.can_double_down && !playerHand.player.has_hit)
                {
                    std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldDD << " or " << ShouldHit << "." << std::endl;
                }
                else if (playerHand.player.cards.size() > 2 || !playerHand.player.can_double_down || playerHand.player.has_hit)
                {
                    std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                }
                else {}
                break;
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 1:
                std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                break;
            default:
                break;
            }
        }
        else if (playerHand.player.cards_total == 10)
        {
            switch (dealerHand.player.cards[1].card.card_value)
            {
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
                if (playerHand.player.cards.size() == 2 && playerHand.player.can_double_down && !playerHand.player.has_hit)
                {
                    std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldDD << " or " << ShouldHit << "." << std::endl;
                }
                else if (playerHand.player.cards.size() > 2 || !playerHand.player.can_double_down || playerHand.player.has_hit)
                {
                    std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                }
                else {}
                break;
            case 10:
            case (11):
            case (1):
                std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                break;
            default:
                break;
            }
        }
        else if (playerHand.player.cards_total == 11)
        {
            if (playerHand.player.cards.size() == 2 && playerHand.player.can_double_down && !playerHand.player.has_hit)
            {
                std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldDD << " or " << ShouldHit << "." << std::endl;
            }
            else if (playerHand.player.cards.size() >= 2 || !playerHand.player.can_double_down || playerHand.player.has_hit)
            {
                std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
            }
            else {}
        }
        else if (playerHand.player.cards_total == 12)
        {
            switch (dealerHand.player.cards[1].card.card_value)
            {
            case 2:
            case 3:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 1:
                std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                break;
            case 4:
            case 5:
            case 6:
                std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldStand << "." << std::endl;
                break;
            default:
                break;
            }
        }
        else if (playerHand.player.cards_total == 13 || playerHand.player.cards_total == 14 || playerHand.player.cards_total == 15 || playerHand.player.cards_total == 16)
        {
            switch (dealerHand.player.cards[1].card.card_value)
            {
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
                std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldStand << "." << std::endl;
                break;
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 1:
                std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldHit << "." << std::endl;
                break;
            default:
                break;
            }
        }
        else if (playerHand.player.cards_total == 17 || playerHand.player.cards_total == 18 || playerHand.player.cards_total == 19 || playerHand.player.cards_total == 20)
        {
            std::cout << std::endl << BlackJack << " strategy suggests " << playerHand.player.display_name << " should " << ShouldStand << "." << std::endl;
        }
        else {}
    }
    else {
        std::cout << std::endl << "Fuck" << std::endl;
    }
    
}
// Check For Face Up Ace of Dealer Method - dealer_showing_ace
/*
* This method checks if the dealer has an Ace as a face up card
* This method takes in three parameters for input and returns four parameters as an output
*   - FuncInput(1): playerHand - Hand, this is a Hand object that represents the user
*   - FuncInput(2): dealerHand - Hand, this is a Hand object that represents the dealer
*   - FuncInput(3): shoe - Shoe, this is a Shoe object that represents the game shoe
*   - FuncOutput(1): playerHand - Hand, this is the modified Hand object for the user
*   - FuncOutput(2): dealerhand - Hand, this is the modified Hand object for the dealer
*   - FuncOutput(3): shoe - Hand, this is the modified Shoe object that represents the game shoe
*   - FuncOutput(4): hand_continue - Boolean, this is the boolean value that dictates if the hand is supposed to continue after this method
*/
std::tuple<Hand, Hand, Shoe, bool> dealer_showing_ace(Hand& playerHand, Hand& dealerHand, Shoe& shoe)
{
    float prior_bank_total = playerHand.player.bank_total;
    deal_hand(playerHand, dealerHand, shoe);
    bool hand_continue = true;
    if (check_card_parameter(dealerHand.player.cards.at(1).card.rank, "Ace"))
    {
        if (playerHand.player.can_buy_insurance)
        {
            std::cout << std::endl << "The " << dealerHand.player.display_name << " is showing an " << dealerHand.player.cards.at(1).display_rank << ". "; 
            playerHand.Insurance();
            if (playerHand.player.chose_buy_insurance)
            {
                std::cout << std::endl << playerHand.player.display_name << " has chosen to buy insurance. Your insurance wager" << " is " << playerHand.player.display_insurance_wager << "." << std::endl; 
                if (check_blackjack(dealerHand) && check_blackjack(playerHand))
                {
                    hand_continue = false;
                    std::cout << std::endl << "Both players have blackjack. " << playerHand.player.display_name << " wins insurance and pushes their original wager. ";
                    playerHand.Update_Bank("P", playerHand, playerHand.player.wager);
                    playerHand.Update_Bank("I", playerHand, playerHand.player.insurance_wager);
                    std::cout << playerHand.player.display_name << " nets " << playerHand.player.display_net << " this hand." << std::endl << std::endl; 
                    std::cout << "Here are the final hands of the players:" << std::endl; 
                    playerHand.Show_Hand("final");
                    dealerHand.Show_Hand("final", "Show");
                    update_stats(playerHand);
                    return std::make_tuple(playerHand, dealerHand, shoe, hand_continue);
                }
                else if (check_blackjack(dealerHand) && !(check_blackjack(playerHand)))
                {
                    hand_continue = false;
                    std::cout << std::endl << dealerHand.player.display_name << " has blackjack but " << playerHand.player.display_name << " does not. " << playerHand.player.display_name 
                    << " wins insurance but loses their original wager. ";
                    playerHand.Update_Bank("L", playerHand, playerHand.player.wager);
                    playerHand.Update_Bank("I", playerHand, playerHand.player.insurance_wager);
                    std::cout << playerHand.player.display_name << " nets " << playerHand.player.display_net << " this hand." << std::endl << std::endl; 
                    std::cout << "Here are the final hands of the players:" << std::endl; 
                    playerHand.Show_Hand("final");
                    dealerHand.Show_Hand("final", "Show");
                    update_stats(playerHand);
                    return std::make_tuple(playerHand, dealerHand, shoe, hand_continue);
                }
                else if (!check_blackjack(dealerHand) && (check_blackjack(playerHand)))
                {
                    hand_continue = false;
                    std::cout << std::endl << playerHand.player.display_name << " has blackjack and " << dealerHand.player.display_name << " does not. " << playerHand.player.display_name 
                    << " loses insurance but wins their original wager. ";
                    playerHand.Update_Bank("B", playerHand, playerHand.player.wager);
                    playerHand.Update_Bank("L", playerHand, playerHand.player.insurance_wager);
                    std::cout << playerHand.player.display_name << " nets " << playerHand.player.display_net << " this hand." << std::endl << std::endl ; 
                    std::cout << "Here are the final hands of the players:" << std::endl; 
                    playerHand.Show_Hand("final");
                    dealerHand.Show_Hand("final", "Show");
                    update_stats(playerHand);
                    return std::make_tuple(playerHand, dealerHand, shoe, hand_continue);
                }
                else if (!(check_blackjack(dealerHand)) && !(check_blackjack(playerHand)))
                {
                    hand_continue = true;
                    playerHand.Update_Bank("L", playerHand, playerHand.player.insurance_wager);
                    std::cout << std::endl << "Neither player has blackjack. " << playerHand.player.display_name << " loses their insurance wager. The hand will continue." << std::endl << std::endl; ; 
                    std::cout << "Here are the current hands of each player:" << std::endl; 
                    playerHand.Show_Hand("initial");
                    dealerHand.Show_Hand("initial");
                    return std::make_tuple(playerHand, dealerHand, shoe, hand_continue);
                }
                else {}
            }
            else if (!playerHand.player.chose_buy_insurance)
            {
                std::cout << std::endl << playerHand.player.display_name << " has chosen to not buy insurance." << std::endl; 
                if (check_blackjack(dealerHand) && check_blackjack(playerHand))
                {
                    hand_continue = false;
                    std::cout << std::endl << "Both players have blackjack. " << playerHand.player.display_name << " pushes their original wager. ";
                    playerHand.Update_Bank("P", playerHand, playerHand.player.wager);
                    std::cout << playerHand.player.display_name << " nets " << playerHand.player.display_net << " this hand." << std::endl << std::endl; 
                    std::cout << "Here are the final hands of the players:" << std::endl; 
                    playerHand.Show_Hand("final");
                    dealerHand.Show_Hand("final", "Show");
                    update_stats(playerHand);
                    return std::make_tuple(playerHand, dealerHand, shoe, hand_continue);
                }
                else if (check_blackjack(dealerHand) && !(check_blackjack(playerHand)))
                {
                    hand_continue = false;
                    std::cout << std::endl << dealerHand.player.display_name << " has blackjack but " << playerHand.player.display_name << " does not. " 
                    << playerHand.player.display_name << " loses their original wager. ";
                    playerHand.Update_Bank("L", playerHand, playerHand.player.wager);
                    std::cout << playerHand.player.display_name << " nets " << playerHand.player.display_net << " this hand." << std::endl << std::endl; 
                    std::cout << "Here are the final hands of the players:" << std::endl; 
                    playerHand.Show_Hand("final");
                    dealerHand.Show_Hand("final", "Show");
                    update_stats(playerHand);
                    return std::make_tuple(playerHand, dealerHand, shoe, hand_continue);
                }
                else if (!check_blackjack(dealerHand) && (check_blackjack(playerHand)))
                {
                    hand_continue = false;
                    std::cout << std::endl << playerHand.player.display_name << " has blackjack and " << dealerHand.player.display_name << " does not. " << playerHand.player.display_name 
                    << " wins their original wager. ";
                    playerHand.Update_Bank("B", playerHand, playerHand.player.wager);
                    std::cout << playerHand.player.display_name << " nets " << playerHand.player.display_net << " this hand." << std::endl << std::endl; 
                    std::cout << "Here are the final hands of the players:" << std::endl; 
                    playerHand.Show_Hand("final");
                    dealerHand.Show_Hand("final", "Show");
                    update_stats(playerHand);
                    return std::make_tuple(playerHand, dealerHand, shoe, hand_continue);
                }
                else if (!(check_blackjack(dealerHand)) && !(check_blackjack(playerHand)))
                {
                    hand_continue = true;
                    std::cout << std::endl << "Neither player has blackjack. The hand will continue." << std::endl << std::endl; 
                    std::cout << "Here are the current hands of each player:" << std::endl; 
                    playerHand.Show_Hand("initial");
                    dealerHand.Show_Hand("initial");
                    return std::make_tuple(playerHand, dealerHand, shoe, hand_continue);
                }
                else {}
            }
        }
        else if (!playerHand.player.can_buy_insurance)
        {
            std::cout << std::endl << "The " << dealerHand.player.display_name << " is showing an " << dealerHand.player.cards.at(1).display_rank << ". But " << playerHand.player.display_name
            << " does not have enough currency in their bank to purchase insurance." << std::endl; 
            if (check_blackjack(dealerHand) && check_blackjack(playerHand))
            {
                hand_continue = false;
                std::cout << std::endl << "Both players have blackjack. " << playerHand.player.display_name << " pushes their original wager."; 
                playerHand.Update_Bank("P", playerHand, playerHand.player.wager);
                std::cout << playerHand.player.display_name << " nets " << playerHand.player.display_net << " this hand." << std::endl << std::endl; 
                std::cout << "Here are the final hands of the players:" << std::endl; 
                playerHand.Show_Hand("final");
                dealerHand.Show_Hand("final", "Show");
                update_stats(playerHand);
                return std::make_tuple(playerHand, dealerHand, shoe, hand_continue);
            }
            else if (check_blackjack(dealerHand) && !(check_blackjack(playerHand)))
            {
                hand_continue = false;
                std::cout << std::endl << dealerHand.player.display_name << " has blackjack but " << playerHand.player.display_name << " does not. " 
                << playerHand.player.display_name << " loses their original wager.";
                playerHand.Update_Bank("L", playerHand, playerHand.player.wager);
                std::cout << playerHand.player.display_name << " nets " << playerHand.player.display_net << " this hand." << std::endl << std::endl; 
                std::cout << "Here are the final hands of the players:" << std::endl; 
                playerHand.Show_Hand("final");
                dealerHand.Show_Hand("final", "Show");
                update_stats(playerHand);
                return std::make_tuple(playerHand, dealerHand, shoe, hand_continue);
            }
            else if (!check_blackjack(dealerHand) && (check_blackjack(playerHand)))
            {
                hand_continue = false;
                std::cout << std::endl << playerHand.player.display_name << " has blackjack and " << dealerHand.player.display_name << " does not. " 
                << playerHand.player.display_name << " wins their original wager. ";
                playerHand.Update_Bank("B", playerHand, playerHand.player.wager);
                std::cout << playerHand.player.display_name << " nets " << playerHand.player.display_net << " this hand." << std::endl << std::endl; 
                std::cout << "Here are the final hands of the players:" << std::endl; 
                playerHand.Show_Hand("final");
                dealerHand.Show_Hand("final", "Show");
                update_stats(playerHand);
                return std::make_tuple(playerHand, dealerHand, shoe, hand_continue);
            }
            else if (!(check_blackjack(dealerHand)) && !(check_blackjack(playerHand)))
            {
                hand_continue = true;
                return std::make_tuple(playerHand, dealerHand, shoe, hand_continue);
            }
            else {}
        }
    }
    else if (!check_card_parameter(dealerHand.player.cards.at(1).card.rank, "Ace"))
    {
        if (check_blackjack(dealerHand) && check_blackjack(playerHand))
        {
            hand_continue = false;
            std::cout << std::endl << "Both players have blackjack. " << playerHand.player.display_name << " pushes their original wager. ";
            playerHand.Update_Bank("P", playerHand, playerHand.player.wager);
            std::cout << playerHand.player.display_name << " nets " << playerHand.player.display_net << " this hand." << std::endl << std::endl; 
            std::cout << "Here are the final hands of the players:" << std::endl; 
            playerHand.Show_Hand("final");
            dealerHand.Show_Hand("final", "Show");
            update_stats(playerHand);
            return std::make_tuple(playerHand, dealerHand, shoe, hand_continue);
        }
        else if (check_blackjack(dealerHand) && !(check_blackjack(playerHand)))
        {
            hand_continue = false;
            std::cout << std::endl << dealerHand.player.display_name << " has blackjack but " << playerHand.player.display_name << " does not. " 
            << playerHand.player.display_name << " loses their original wager. ";
            playerHand.Update_Bank("L", playerHand, playerHand.player.wager);
            std::cout << playerHand.player.display_name << " nets " << playerHand.player.display_net << " this hand." << std::endl << std::endl; 
            std::cout << "Here are the final hands of the players:" << std::endl; 
            playerHand.Show_Hand("final");
            dealerHand.Show_Hand("final", "Show");
            update_stats(playerHand);
            return std::make_tuple(playerHand, dealerHand, shoe, hand_continue);
        }
        else if (!check_blackjack(dealerHand) && (check_blackjack(playerHand)))
        {
            hand_continue = false;
            std::cout << std::endl << playerHand.player.display_name << " has blackjack and " << dealerHand.player.display_name << " does not. " 
            << playerHand.player.display_name << " wins their original wager. ";
            playerHand.Update_Bank("B", playerHand, playerHand.player.wager);
            std::cout << playerHand.player.display_name << " nets " << playerHand.player.display_net << " this hand." << std::endl << std::endl; 
            std::cout << "Here are the final hands of the players:" << std::endl; 
            playerHand.Show_Hand("final");
            dealerHand.Show_Hand("final", "Show");
            update_stats(playerHand);
            return std::make_tuple(playerHand, dealerHand, shoe, hand_continue);
        }
        else if (!(check_blackjack(dealerHand)) && !(check_blackjack(playerHand)))
        {
            hand_continue = true;
            return std::make_tuple(playerHand, dealerHand, shoe, hand_continue);
        }
        else {}
    }
    else {}
}
// Split Hand Method - split_hand
/*
* This method splits the hand of a user
* This method takes in one input, a Hand object, and returns a vector of hands
*   - FuncInput(1): inputHand - Hand, this is the hand object that is fed into the method to be split
*   - FuncOutput(1): hands - Vector, this is the vector of hands that is created after the original hand is split
*/
std::vector<Hand> split_hand(Hand& inputHand)
{
    std::vector<Hand> hands;
    inputHand.player.bank_total -= inputHand.player.wager;
    inputHand.player.display_bank_total = color_text(33, round_to_string(inputHand.player.bank_total));
    for (Card card : inputHand.player.cards)
    {
        Hand current_hand;
        current_hand.player.cards.push_back(card);
        hands.push_back(current_hand);
    }
    for (Hand& current_hand : hands) {
        current_hand.Copy_Variables(inputHand);
    }
    return hands;
}
// Player Same Rank Method - player_same_rank
/*
* This method determines if a player has the same rank of a card in their hand
* This method takes in two hands and a shoe as an input and returns a vector of hands, two modified hands, a modified shoe, and an integer
*   - FuncInput(1): playerHand - Hand, this is the original player hand that is fed into the method to check if a player has duplicate ranks
*   - FuncInput(2): dealerHand - Hand, this is the original dealer hand that is fed into the method
*   - FuncInput(3): shoe - Shoe, this is shoe that is being played with
*   - FuncOutput(1): new_hand - Vector, this is a vector of hands that is returned after the logical process of this method
*   - FuncOutput(2): playerHand - Hand, this is the modified hand object of the original players hand
*   - FuncOutput(3): dealerHand - Hand, this is the modified hand object of the original dealer hand
*   - FuncOutput(4): shoe - Shoe, this is the modified shoe object of the shoe that is being played with
*   - FuncOutput(5): hand_count - Integer, this is an integer value that tells the computer how many hands a player ends up with after this method
*/
std::tuple<std::vector<Hand>, Hand, Hand, Shoe, int> player_same_rank(Hand& playerHand, Hand& dealerHand, Shoe& shoe)
{
    int hand_count = 1;
    std::vector<Hand> new_hand;
    if (playerHand.player.can_split_hand)
    {
        if (check_same_parameter_in_hand(playerHand, "R", "Ace"))
        {
            std::string aces_response;
            while (aces_response.empty())
            {
                std::cout << std::endl << "You have the same rank of " << playerHand.player.cards[0].display_rank << " in your hand." << std::endl; 
                std::cout << std::endl << "Would you like to split your hand? You may only split your hand once." << std::endl; 
                blackjack_strategy(playerHand, dealerHand, false);
                std::cout << std::endl << "Enter (y) for yes and (n) for no: ";
                std::cin >> aces_response;
                std::cout << std::endl; 
                if (aces_response == "y")
                {
                    playerHand.player.chose_split_aces = true;
                    playerHand.player.split_decision = true;
                    std::cout << playerHand.player.display_name << " has chosen to split their " << playerHand.player.cards[0].display_rank << "'s." << std::endl; 
                    std::cout << std::endl << "Here are the current hands of both players: " << std::endl; 
                    std::vector<Hand> split_aces = split_hand(playerHand);
                    Hand player_hand_1 = split_aces.at(0);
                    Hand player_hand_2 = split_aces.at(1);
                    player_hand_1.Hit(shoe);
                    player_hand_2.Hit(shoe);
                    new_hand.push_back(player_hand_1);
                    new_hand.push_back(player_hand_2);
                    hand_count = 2;
                    int loop_counter = 1;
                    std::string hand_tracker;
                    for (Hand& current_hand : new_hand)
                    {
                        if (loop_counter == 1)
                        {
                            hand_tracker = "first";
                        }
                        else if (loop_counter == 2)
                        {
                            hand_tracker = "second";
                        }
                        else {}
                        current_hand.Show_Hand(hand_tracker);
                        loop_counter++;
                    }
                    dealerHand.Show_Hand();
                    playerHand.Copy_Variables(new_hand.back());
                    return std::make_tuple(new_hand, playerHand, dealerHand, shoe, hand_count);
                }
                else if (aces_response == "n")
                {
                    playerHand.player.chose_split_aces = false;
                    playerHand.player.split_decision = true;
                    std::cout << playerHand.player.display_name << " has chosen not to split their " << playerHand.player.cards[0].display_rank << "'s." << std::endl; 
                    new_hand.push_back(playerHand);
                    playerHand.Copy_Variables(new_hand.back());
                    return std::make_tuple(new_hand, playerHand, dealerHand, shoe, hand_count);
                }
                else
                {
                    std::cout << color_text(31, "Invalid choice") + " of " + color_text(31, aces_response) + ". Plese re-enter your decision." << std::endl << std::endl; 
                    aces_response.clear();
                }
            }
        }
        else if (check_same_parameter_in_hand(playerHand, "R") && !check_card_parameter(playerHand.player.cards[0].card.rank, "Ace"))
        {
            std::string same_rank_response;
            while (same_rank_response.empty())
            {
                std::cout << std::endl << "You have the same rank of " << playerHand.player.cards[0].display_rank << " in your hand." << std::endl; 
                std::cout << std::endl << "Would you like to split your hand? You may split up to a total of four times." << std::endl; 
                blackjack_strategy(playerHand, dealerHand, false);
                std::cout << std::endl << "Enter (y) for yes and (n) for no: ";
                std::cin >> same_rank_response;
                if (same_rank_response == "y")
                {
                    playerHand.player.chose_split_hand = true;
                    playerHand.player.split_decision = true;
                    std::cout << std::endl << playerHand.player.display_name << " has chosen to split their hand." << std::endl; 
                    int split_counter = 1;
                    hand_count++;
                    std::vector<Hand> initial_split = split_hand(playerHand);
                    std::vector<Hand> split_hands;
                    std::vector<Hand> temp_hands;
                    Hand player_hand_1 = initial_split.at(0);
                    Hand player_hand_2 = initial_split.at(1);
                    player_hand_2.Hit(shoe);
                    temp_hands.push_back(player_hand_2);
                    temp_hands.push_back(player_hand_1);
                    Hand checking_hand;
                    checking_hand = player_hand_2;
                    checking_hand.Copy_Variables(player_hand_2);
                    special_options(checking_hand, dealerHand, false);
                    if (check_same_parameter_in_hand(checking_hand, "R"))
                    {
                        if (checking_hand.player.can_split_hand)
                        {
                            std::cout << std::endl << "Total times split: " << color_text(31, std::to_string(split_counter)) << ". Your current hand(s) are:" << std::endl; 
                            int loop_counter = 1;
                            std::string hand_tracker;
                            for (Hand& current_hand : temp_hands)
                            {
                                if (loop_counter == 1)
                                {
                                    hand_tracker = "first";
                                }
                                else if (loop_counter == 2)
                                {
                                    hand_tracker = "second";
                                }
                                else {}
                                current_hand.Show_Hand(hand_tracker);
                                loop_counter++;
                            }
                            temp_hands.clear();
                            while (split_counter < 4 && checking_hand.player.can_split_hand)
                            {
                                std::string split_again;
                                while (split_again != "y" || split_again != "n")
                                {
                                    std::cout << std::endl << std::endl << "You have pulled the same rank of " << checking_hand.player.cards[0].display_rank 
                                    << " again." << std::endl; 
                                    std::cout << std::endl << "Would you like to split your current hand again?" << std::endl; 
                                    blackjack_strategy(checking_hand, dealerHand, false);
                                    std::cout << std::endl << "Enter (y) for yes and (n) for no: ";
                                    std::cin >> split_again;
                                    std::cout << std::endl;
                                    if (split_again == "y")
                                    {
                                        split_counter++;
                                        hand_count++;
                                        std::vector<Hand> new_split = split_hand(checking_hand);
                                        Hand new_player_hand_1 = new_split.at(0);
                                        Hand new_player_hand_2 = new_split.at(1);
                                        new_player_hand_2.Hit(shoe);
                                        split_hands.insert(split_hands.begin(), new_player_hand_1);
                                        checking_hand = new_player_hand_2;
                                        checking_hand.Copy_Variables(new_player_hand_2);
                                        special_options(checking_hand, dealerHand, false);
                                        break;
                                    }
                                    else if (split_again == "n")
                                    {
                                        break;
                                    }
                                    else
                                    {
                                        std::cout << color_text(31, "Invalid Entry") << ". Please enter a valid choice." << std::endl; 
                                        split_again.clear();
                                    }
                                }
                                split_hands.insert(split_hands.begin(), checking_hand);
                                split_hands.insert(split_hands.end(), player_hand_1);
                                for (int i = 0; i < split_hands.size(); i++)
                                {
                                    split_hands.at(i).Copy_Variables(checking_hand);
                                }
                                if (checking_hand.player.can_split_hand && split_again == "y")
                                {
                                    if (split_counter < 4 && checking_hand.player.can_split_hand)
                                    {
                                        std::cout << playerHand.player.display_name << " has chosen to split their hand again." << std::endl; 
                                        std::cout << std::endl << "Total times split: " << color_text(31, std::to_string(split_counter)) << ". Your current hand(s) are:" << std::endl; 
                                        int loop_counter = 1;
                                        std::string hand_tracker;
                                        for (Hand& current_hand : split_hands)
                                        {
                                            if (loop_counter == 1)
                                            {
                                                hand_tracker = "first";
                                            }
                                            else if (loop_counter == 2)
                                            {
                                                hand_tracker = "second";
                                            }
                                            else if (loop_counter == 3)
                                            {
                                                hand_tracker = "third";
                                            }
                                            else if (loop_counter == 4)
                                            {
                                                hand_tracker = "fourth";
                                            }
                                            else
                                            {
                                                hand_tracker = "current";
                                            }
                                            current_hand.Show_Hand(hand_tracker);
                                            loop_counter++;
                                        }
                                        split_hands.erase(split_hands.begin());
                                        split_hands.pop_back();
                                        continue;
                                    }
                                    else if (split_counter == 4 || !checking_hand.player.can_split_hand)
                                    {
                                        if (split_counter == 4)
                                        {
                                            std::cout << playerHand.player.display_name << " has reached the max amount of times to split." << std::endl; 
                                            std::cout << std::endl << "Total times split: " << color_text(31, std::to_string(split_counter)) << ". Your current hand(s) are:" << std::endl; 
                                            int loop_counter = 1;
                                            std::string hand_tracker;
                                            for (Hand& current_hand : split_hands)
                                            {
                                                if (loop_counter == 1)
                                                {
                                                    hand_tracker = "first";
                                                }
                                                else if (loop_counter == 2)
                                                {
                                                    hand_tracker = "second";
                                                }
                                                else if (loop_counter == 3)
                                                {
                                                    hand_tracker = "third";
                                                }
                                                else if (loop_counter == 4)
                                                {
                                                    hand_tracker = "fourth";
                                                }
                                                else if (loop_counter == 5)
                                                {
                                                    hand_tracker = "fifth";
                                                }
                                                else
                                                {
                                                    hand_tracker = "current";
                                                }
                                                current_hand.Show_Hand(hand_tracker);
                                                loop_counter++;
                                            }
                                            std::cout << std::endl << std::endl;
                                        }
                                        else if (!checking_hand.player.can_split_hand)
                                        {
                                            if (checking_hand.player.bank_total < checking_hand.player.wager) 
                                            {
                                                std::cout << "Your current bank balance of " << checking_hand.player.display_bank_total << " is not greater than"
                                                << " your wager of " << checking_hand.player.display_wager << ". You can no longer split your hands. Total times split: " 
                                                << color_text(31, std::to_string(split_counter)) << ". Your current hand(s) are:" << std::endl; 
                                            }
                                            else {}
                                            int loop_counter = 1;
                                            std::string hand_tracker;
                                            for (Hand& current_hand : split_hands)
                                            {
                                                if (loop_counter == 1)
                                                {
                                                    hand_tracker = "first";
                                                }
                                                else if (loop_counter == 2)
                                                {
                                                    hand_tracker = "second";
                                                }
                                                else if (loop_counter == 3)
                                                {
                                                    hand_tracker = "third";
                                                }
                                                else if (loop_counter == 4)
                                                {
                                                    hand_tracker = "fourth";
                                                }
                                                else
                                                {
                                                    hand_tracker = "current";
                                                }
                                                current_hand.Show_Hand(hand_tracker);
                                                loop_counter++;
                                            }
                                            std::cout << std::endl << std::endl;
                                        }
                                        break;
                                    }
                                    else {}
                                }
                                else if (!checking_hand.player.can_split_hand || split_again == "n")
                                {
                                    if (!checking_hand.player.can_split_hand)
                                    {
                                        if (checking_hand.player.bank_total < checking_hand.player.wager) {
                                            std::cout << "You pulled the same rank of " << checking_hand.player.cards[0].display_rank << " again but you do not have enough currency to continue splitting. ";
                                            std::cout << std::endl << std::endl << "Total times split: " << color_text(31, std::to_string(split_counter)) << ". Your current hand(s) are: " << std::endl; 
                                        }
                                        else if (checking_hand.player.bank_total >= checking_hand.player.wager) {
                                            std::cout << "You did not pull the same rank of " << checking_hand.player.cards[0].display_rank << " again. You can no longer split your hands."; 
                                            std::cout << std::endl << std::endl << "Total times split: " << color_text(31, std::to_string(split_counter)) << ". Your current hand(s) are: " << std::endl; 
                                        }
                                        else {}
                                        int loop_counter = 1;
                                        std::string hand_tracker;
                                        for (Hand& current_hand : split_hands)
                                        {
                                            if (loop_counter == 1)
                                            {
                                                hand_tracker = "first";
                                            }
                                            else if (loop_counter == 2)
                                            {
                                                hand_tracker = "second";
                                            }
                                            else if (loop_counter == 3)
                                            {
                                                hand_tracker = "third";
                                            }
                                            else if (loop_counter == 4)
                                            {
                                                hand_tracker = "fourth";
                                            }
                                            else
                                            {
                                                hand_tracker = "current";
                                            }
                                            current_hand.Show_Hand(hand_tracker);
                                            loop_counter++;
                                        }
                                        std::cout << std::endl << std::endl;
                                    }
                                    else if (split_again == "n")
                                    {
                                        std::cout << playerHand.player.display_name << " has chosen not to split their hand again." << std::endl << std::endl << "Total times split: " 
                                        << color_text(31, std::to_string(split_counter)) << ". Your current hand(s) are:" << std::endl; 
                                        int loop_counter = 1;
                                        std::string hand_tracker;
                                        for (Hand &current_hand : split_hands)
                                        {
                                            if (loop_counter == 1)
                                            {
                                                hand_tracker = "first";
                                            }
                                            else if (loop_counter == 2)
                                            {
                                                hand_tracker = "second";
                                            }
                                            else if (loop_counter == 3)
                                            {
                                                hand_tracker = "third";
                                            }
                                            else if (loop_counter == 4)
                                            {
                                                hand_tracker = "fourth";
                                            }
                                            else
                                            {
                                                hand_tracker = "current";
                                            }
                                            current_hand.Show_Hand(hand_tracker);
                                            loop_counter++;
                                        }
                                        std::cout << std::endl << std::endl;
                                    }
                                    else {}
                                    break;
                                }
                            }
                            new_hand = split_hands;
                            playerHand.Copy_Variables(new_hand.back());
                            return std::make_tuple(new_hand, playerHand, dealerHand, shoe, hand_count);
                        }
                        else if (!checking_hand.player.can_split_hand)
                        {
                            std::cout << std::endl << "You have pulled the same rank of " << checking_hand.player.cards[0].display_rank << " again." << std::endl;
                            int loop_counter = 1;
                            std::string hand_tracker;
                            for (Hand& current_hand : temp_hands)
                            {
                                if (loop_counter == 1)
                                {
                                    hand_tracker = "first";
                                }
                                else if (loop_counter == 2)
                                {
                                    hand_tracker = "second";
                                }
                                else
                                {
                                    hand_tracker = "current";
                                }
                                current_hand.Show_Hand(hand_tracker);
                                loop_counter++; 
                            }
                            std::cout << std::endl << "Your current bank balance of " << checking_hand.player.display_bank_total << " is not  greater than your wager of " 
                            << checking_hand.player.display_wager << ". You can no longer split your hands. Total times split: " << color_text(31, std::to_string(split_counter)) << std::endl;
                            new_hand = temp_hands;
                            playerHand.Copy_Variables(new_hand.back());
                            return std::make_tuple(new_hand, playerHand, dealerHand, shoe, hand_count);
                        }
                        else {}
                    }
                    else if (!check_same_parameter_in_hand(checking_hand, "R"))
                    {
                        new_hand.insert(new_hand.begin(), checking_hand);
                        new_hand.push_back(player_hand_1);
                        std::cout << std::endl << "Total times split: " << color_text(31, std::to_string(split_counter)) << ". Your current hand(s) are:" << std::endl; 
                        int loop_counter = 1;
                        std::string hand_tracker;
                        for (Hand &current_hand : new_hand)
                        {
                            if (loop_counter == 1)
                            {
                                hand_tracker = "first";
                            }
                            else if (loop_counter == 2)
                            {
                                hand_tracker = "second";
                            }
                            else {}
                            current_hand.Show_Hand(hand_tracker);
                            loop_counter++;
                        }
                        std::cout << std::endl;
                        playerHand.Copy_Variables(new_hand.back());
                        return std::make_tuple(new_hand, playerHand, dealerHand, shoe, hand_count);
                    }
                    else {}
                }
                else if (same_rank_response == "n")
                {
                    playerHand.player.chose_split_hand = false;
                    playerHand.player.split_decision = true;
                    new_hand.push_back(playerHand);
                    std::cout << std::endl << playerHand.player.display_name << " has chosen not to split their hand." << std::endl; 
                    playerHand.Copy_Variables(new_hand.back());
                    return std::make_tuple(new_hand, playerHand, dealerHand, shoe, hand_count);
                }
                else
                {
                    std::cout << std::endl << color_text(31, "Invalid choice") + " of " + color_text(31, same_rank_response) + ". Plese re-enter your decision." << std::endl; 
                    same_rank_response.clear();
                }
            }
        }
        else if (!check_same_parameter_in_hand(playerHand, "R"))
        {
            new_hand.push_back(playerHand);
            playerHand.Copy_Variables(new_hand.back());
            return std::make_tuple(new_hand, playerHand, dealerHand, shoe, hand_count);
        }
        else {}
    }
    else if (!playerHand.player.can_split_hand)
    {
        new_hand.push_back(playerHand);
        playerHand.Copy_Variables(new_hand.back());
        return std::make_tuple(new_hand, playerHand, dealerHand, shoe, hand_count);
    }
    else {}
}
// Player Hand Logic - player_hand_logic
std::tuple<Hand, Hand, Hand, Shoe> player_hand_logic(Hand& playerHand, Hand& dealerHand, Hand& referenceHand, Shoe& shoe, int& hand_counter)
{
    if (!referenceHand.player.chose_split_aces) 
    {
        std::string response;
        std::string hand_tracker;
        if (hand_counter == 1)
        {
            hand_tracker = "first";
        }
        else if (hand_counter == 2)
        {
            hand_tracker = "second";
        }
        else if (hand_counter == 3)
        {
            hand_tracker = "third";
        }
        else if (hand_counter == 4)
        {
            hand_tracker = "fourth";
        }
        else if (hand_counter == 5)
        {
            hand_tracker = "fifth";
        }
        else
        {
            hand_tracker = "current";
        }
        if (hand_counter > 1)
        {
            playerHand.Hit(shoe);
        }
        else {}
        while ((response != "h" && response != "s" && response != "d") && playerHand.player.cards_total < 21)
        {
            if (!playerHand.player.has_hit)
            {
                if (referenceHand.player.chose_split_hand)
                {
                    std::cout << std::endl << "Here are the initial hands of each player for hand " << std::to_string(hand_counter) << ":" << std::endl; 
                    playerHand.Show_Hand("initial " + hand_tracker);
                    dealerHand.Show_Hand("initial");
                    std::cout << std::endl << "Would you like to hit, stand, or double down for hand " << std::to_string(hand_counter) << "?" << std::endl; 
                    blackjack_strategy(playerHand, dealerHand, true);
                    std::cout << std::endl << "Enter (h) to hit, (s) to stand, and (d) to double down for " << std::to_string(hand_counter) << ": ";
                    std::cin >> response;
                    std::cout << std::endl;
                }
                else if (!referenceHand.player.chose_split_hand)
                {
                    std::cout << std::endl << "Would you like to hit, stand, or double down?" << std::endl; 
                    blackjack_strategy(playerHand, dealerHand, true);
                    std::cout << std::endl << "Enter (h) to hit, (s) to stand, and (d) to double down: ";
                    std::cin >> response;
                    std::cout << std::endl;
                }
                else {}            
            }
            else if (playerHand.player.has_hit)
            {
                
                if (referenceHand.player.chose_split_hand)
                {
                    playerHand.Show_Hand("current " + hand_tracker);
                }
                else if (!referenceHand.player.chose_split_hand)
                {
                    playerHand.Show_Hand("current");
                }
                else {}
                dealerHand.Show_Hand("initial");
                std::cout << std::endl << "Would you like to hit (h) or stand (s)?" << std::endl; 
                blackjack_strategy(playerHand, dealerHand, true);
                std::cout << std::endl << "Enter (h) to hit and (s) to stand: ";
                std::cin >> response;
                std::cout << std::endl;
            }
            else {}
            if (response == "h")
            {
                playerHand.player.has_hit = true;
                playerHand.Hit(shoe);
                if (playerHand.player.cards_total > 21)
                {
                    std::cout << playerHand.player.display_name << " has chosen to hit and busted. Final hand total: " << playerHand.player.display_cards_total << "." << std::endl; 
                    if (referenceHand.player.chose_split_hand)
                    {
                        std::cout << std::endl << "Here is " << playerHand.player.display_name << "'s final hand for hand " << std::to_string(hand_counter)
                        << " and the " << dealerHand.player.display_name << "'s current hand:" << std::endl; 
                        playerHand.Show_Hand("final " + hand_tracker);
                        dealerHand.Show_Hand("current");
                    }
                    else if (!referenceHand.player.chose_split_hand)
                    {
                        std::cout << std::endl << "Here is the final hand for " << playerHand.player.display_name << " and the final hand of the " << dealerHand.player.display_name << ":" << std::endl; 
                        playerHand.Show_Hand("final");
                        dealerHand.Show_Hand("final", "show");
                    }
                    else {}
                    std::cout << std::endl;
                    
                    break;
                }
                else if (playerHand.player.cards_total < 21)
                {
                    std::cout << playerHand.player.display_name << " has chosen to hit. Current hand total: " << playerHand.player.display_cards_total << "." << std::endl; 
                    if (referenceHand.player.chose_split_hand)
                    {
                        std::cout << std::endl << "Here are the current hands of each player for hand " << std::to_string(hand_counter) << ":" << std::endl;
                    }
                    else if (!referenceHand.player.chose_split_hand)
                    {
                        std::cout << std::endl << "Here are the current hands of each player:" << std::endl;
                    }
                    else {}
                }
                else if (playerHand.player.cards_total == 21)
                {
                    std::cout << playerHand.player.display_name << " has chosen to hit. Final hand total: " << playerHand.player.display_cards_total << "." << std::endl; 
                    if (referenceHand.player.chose_split_hand)
                    {
                        std::cout << std::endl << "Here is " << playerHand.player.display_name << "'s final hand for hand " << std::to_string(hand_counter) << " and the " 
                        << dealerHand.player.display_name << "'s current hand:" << std::endl; 
                        playerHand.Show_Hand("final " + hand_tracker);
                        dealerHand.Show_Hand("current", "");
                    }
                    else if (!referenceHand.player.chose_split_hand)
                    {
                        std::cout << std::endl << "Here is the final hand for " << playerHand.player.display_name << " and the initial hand of the " 
                        << dealerHand.player.display_name << ":" << std::endl; 
                        playerHand.Show_Hand("final");
                        dealerHand.Show_Hand("initial", "show");
                    }
                    else
                    std::cout << std::endl;
                    
                }
                else {}
                response.clear();
            }
            else if (response == "s")
            {
                std::cout << playerHand.player.display_name << " has chosen to stand. Final hand total: " << playerHand.player.display_cards_total << "." << std::endl; 
                if (referenceHand.player.chose_split_hand)
                {
                    std::cout << std::endl << "Here is " << playerHand.player.display_name << "'s final hand for hand " << std::to_string(hand_counter)
                    << " and the " << dealerHand.player.display_name << "'s current hand:" << std::endl; 
                    playerHand.Show_Hand("final " + hand_tracker);
                    dealerHand.Show_Hand("current", "");
                }
                else if (!referenceHand.player.chose_split_hand)
                {
                    std::cout << std::endl << "Here is the final hand for " << playerHand.player.display_name << " and the initial hand of the " 
                    << dealerHand.player.display_name << ":" << std::endl; 
                    playerHand.Show_Hand("final");
                    dealerHand.Show_Hand("initial", "show");
                }
                else
                std::cout << std::endl;
                
                break;
            }
            else if (response == "d" && !playerHand.player.has_hit)
            {
                if (playerHand.player.bank_total >= playerHand.player.wager)
                {
                    playerHand.player.bank_total -= playerHand.player.wager;
                    playerHand.player.wager *= 2;
                    playerHand.Hit(shoe);
                    if (playerHand.player.cards_total > 21)
                    {
                        playerHand.Update_Bank("L", playerHand, playerHand.player.wager);
                        std::cout << playerHand.player.display_name << " has doubled down and busted. Final hand total: " 
                        << playerHand.player.display_cards_total << "." << std::endl; 
                        if (referenceHand.player.chose_split_hand)
                        {
                            std::cout << std::endl << "Here is " << playerHand.player.display_name << "'s final hand for hand " << std::to_string(hand_counter)
                            << " and the " << dealerHand.player.display_name << "'s current hand:" << std::endl; 
                            playerHand.Show_Hand("final " + hand_tracker);
                            dealerHand.Show_Hand("current");
                        }
                        else if (!referenceHand.player.chose_split_hand)
                        {
                            std::cout << std::endl << "Here is the final hand for " << playerHand.player.display_name << " and the final hand of the " 
                            << dealerHand.player.display_name << ":" << std::endl; 
                            playerHand.Show_Hand("final");
                            dealerHand.Show_Hand("final", "show");
                        }
                        else
                        std::cout << std::endl;
                        
                        break;
                    }
                    else if (playerHand.player.cards_total <= 21)
                    {
                        std::cout << playerHand.player.display_name << " has doubled down. Final hand total: " << playerHand.player.display_cards_total << "." << std::endl; 
                        if (referenceHand.player.chose_split_hand)
                        {
                            std::cout << std::endl << "Here is " << playerHand.player.display_name << "'s final hand for hand " << std::to_string(hand_counter) << " and the " 
                            << dealerHand.player.display_name << "'s current hand:" << std::endl; 
                            playerHand.Show_Hand("final " + hand_tracker);
                            dealerHand.Show_Hand("current");
                        }
                        else if (!referenceHand.player.chose_split_hand)
                        {
                            std::cout << std::endl << "Here is the final hand for " << playerHand.player.display_name << " and the initial hand of the " 
                            << dealerHand.player.display_name << ":" << std::endl; 
                            playerHand.Show_Hand("final");
                            dealerHand.Show_Hand("initial", "show");
                        }
                        else {}
                        std::cout << std::endl;
                        
                        break;
                    }
                    else {}
                }
                else if (playerHand.player.bank_total < playerHand.player.wager)
                {
                    std::cout << "Your current bank total of " << playerHand.player.display_bank_total << " is not greater than your wager of "
                    << playerHand.player.display_wager << ". You cannot double down." << std::endl;
                    response.clear();
                    continue;
                }
                else {}
            }
            else if (response != "h" && response != "s" && response != "d")
            {
                if (!referenceHand.player.chose_split_hand)
                {
                    std::cout << color_text(31, "Invalid choice") << "." << std::endl; 
                }
                else if (referenceHand.player.chose_split_hand)
                {
                    std::cout << color_text(31, "Invalid choice") << "." << std::endl << std::endl; 
                }
                else {}            
                response.clear();
                continue;
            }
            else {}
        }
        referenceHand.Copy_Variables(playerHand);
        return std::make_tuple(playerHand, dealerHand, referenceHand, shoe);
    }
    else if (referenceHand.player.chose_split_aces) {
        referenceHand.Copy_Variables(playerHand);
        return std::make_tuple(playerHand, dealerHand, referenceHand, shoe);
    }
    else {}
}
// Dealer Hand Logic
std::tuple<Hand, Shoe> dealer_hand_logic(std::vector<Hand>& playerHands, Hand& dealerHand, Shoe& shoe)
{
    bool all_over_21 = true;
    for (Hand current_hand : playerHands)
    {
        if (current_hand.player.cards_total <= 21)
        {
            all_over_21 = false;
            break;
        }
        else if (current_hand.player.cards_total > 21)
        {
            all_over_21 = true;
            continue;
        }
        else {}
    }
    if (!all_over_21)
    {
        if ((dealerHand.player.cards_total >= 17 && !check_parameter_in_hand(dealerHand, "R", "Ace")) || (dealerHand.player.cards_total > 17 && check_parameter_in_hand(dealerHand, "R", "Ace")))
        {
            int total_hands = playerHands.size();
            if (total_hands > 1)
            {
                int hand_counter = 0;
                std::string hand_tracker;
                std::cout << std::endl << "Here are the final hand(s) of " << playerHands.at(0).player.display_name << " and the " << dealerHand.player.display_name << ":" << std::endl;
                for (Hand current_hand : playerHands)
                {
                    hand_counter++;
                    if (hand_counter == 1)
                    {
                        hand_tracker = " first";
                    }
                    else if (hand_counter == 2)
                    {
                        hand_tracker = " second";
                    }
                    else if (hand_counter == 3)
                    {
                        hand_tracker = " third";
                    }
                    else if (hand_counter == 4)
                    {
                        hand_tracker = " fourth";
                    }
                    else if (hand_counter == 5)
                    {
                        hand_tracker = " fifth";
                    }
                    else {}
                    current_hand.Show_Hand("final" + hand_tracker);
                }
                dealerHand.Show_Hand("final", "show");
                std::cout << std::endl << "The " << dealerHand.player.display_name << " does not need to play their hand with a final total of " 
                << dealerHand.player.display_cards_total << "." << std::endl << std::endl;
            }
            else
            {
                std::cout << std::endl << "The " << dealerHand.player.display_name << " does not need to play their hand with a final total of " << dealerHand.player.display_cards_total << "." << std::endl << std::endl;
            }
        }
        else if (dealerHand.player.cards_total < 17 || (dealerHand.player.cards_total == 17 && check_parameter_in_hand(dealerHand, "R", "Ace")))
        {
            int total_hands = playerHands.size();
            if (total_hands > 1)
            {
                int hand_counter = 0;
                std::string hand_tracker;
                std::cout << std::endl << "Here are the final hand(s) of " << playerHands.at(0).player.display_name << " and the initial hand of the " << dealerHand.player.display_name << ":" << std::endl;
                for (Hand current_hand : playerHands)
                {
                    hand_counter++;
                    if (hand_counter == 1)
                    {
                        hand_tracker = " first";
                    }
                    else if (hand_counter == 2)
                    {
                        hand_tracker = " second";
                    }
                    else if (hand_counter == 3)
                    {
                        hand_tracker = " third";
                    }
                    else if (hand_counter == 4)
                    {
                        hand_tracker = " fourth";
                    }
                    else if (hand_counter == 5)
                    {
                        hand_tracker = " fifth";
                    }
                    else {}
                    current_hand.Show_Hand("final" + hand_tracker);
                }
                dealerHand.Show_Hand("initial", "show");
                std::cout << std::endl << "The " << dealerHand.player.display_name << " will now play their hand." << std::endl << std::endl;
            }
            else
            {
                std::cout << std::endl << "The " << dealerHand.player.display_name << " will now play their hand." << std::endl << std::endl;
            }
            while ((dealerHand.player.cards_total < 17 || (dealerHand.player.cards_total <= 17 && check_parameter_in_hand(dealerHand, "R", "Ace"))))
            {
                bool aces_all_ones = true;
                for (Card current_card : dealerHand.player.cards)
                {
                    if (check_card_parameter(current_card.card.rank, "Ace"))
                    {
                        current_card.card.card_value = 11;
                        aces_all_ones = false;
                        break;
                    }
                    else if (check_card_parameter(current_card.card.rank, "Ace"))
                    {
                        current_card.card.card_value = 1;
                        aces_all_ones = true;
                        continue;
                    }
                    else {}
                }
                if (!aces_all_ones || !check_parameter_in_hand(dealerHand, "R", "Ace"))
                {
                    dealerHand.Hit(shoe);
                    std::cout << dealerHand.player.display_name << " hits hand: ";
                    dealerHand.Show_Hand("", "cards");
                }
                else if (aces_all_ones)
                {
                    std::cout << dealerHand.player.display_name << " final hand ";
                    dealerHand.Show_Hand("", "cards");
                    break;
                }
            }
            std::cout << std::endl;
        }
        else {}
    }
    else if (all_over_21)
    {
        std::cout << playerHands.at(0).player.display_name << " has busted on all of their hands. " << dealerHand.player.display_name << " does not need to play their hand." << std::endl << std::endl;
        int total_hands = playerHands.size();
        if (total_hands > 1)
        {
            int hand_counter = 0;
            std::string hand_tracker;
            std::cout << "The final hands of " << playerHands.at(0).player.display_name << " and the " << dealerHand.player.display_name << " are:" << std::endl;
            for (Hand current_hand : playerHands)
            {
                hand_counter++;
                if (hand_counter == 1)
                {
                    hand_tracker = " first";
                }
                else if (hand_counter == 2)
                {
                    hand_tracker = " second";
                }
                else if (hand_counter == 3)
                {
                    hand_tracker = " third";
                }
                else if (hand_counter == 4)
                {
                    hand_tracker = " fourth";
                }
                else if (hand_counter == 5)
                {
                    hand_tracker = " fifth";
                }
                else {}
                current_hand.Show_Hand("final" + hand_tracker);
            }
            dealerHand.Show_Hand("final", "show");
        }
        else {}
    }
    else {}
    return std::make_tuple(dealerHand, shoe);
}
// Hand Comparison Logic Method
std::tuple<Hand, Hand, Shoe> hand_comparison(Hand& playerHand, Hand& dealerHand, Shoe& shoe, int& playerHandCount, int& currentHandCounter)
{
    std::string hand_tracker;
    bool multiple_hands = false;
    if (playerHandCount > 1)
    {
        multiple_hands = true;
        if (currentHandCounter == 1)
        {
            hand_tracker = " first";
        }
        else if (currentHandCounter == 2)
        {
            hand_tracker = " second";
        }
        else if (currentHandCounter == 3)
        {
            hand_tracker = " third";
        }
        else if (currentHandCounter == 4)
        {
            hand_tracker = " fourth";
        }
        else if (currentHandCounter == 5)
        {
            hand_tracker = " fifth";
        }
        else
        {
            hand_tracker.clear();
        }
    }
    else {}
    if (playerHand.player.cards_total <= 21)
    {
        if (playerHand.player.cards_total == dealerHand.player.cards_total)
        {
            playerHand.Update_Bank("P", playerHand, playerHand.player.wager);
            
            if (!multiple_hands)
            {
                std::cout << "Both players have the same final value of " << playerHand.player.display_cards_total << "." << std::endl; 
                std::cout << std::endl << "The final hands of each player are:" << std::endl; 
                playerHand.Show_Hand("final");
            }
            else if (multiple_hands)
            {
                std::cout << "Both players have the same final value of " << playerHand.player.display_cards_total << " for hand " << std::to_string(currentHandCounter) << ". " << std::endl; 
                std::cout << std::endl << "The final hands of each player for hand " << std::to_string(currentHandCounter) << " are:" << std::endl; 
                playerHand.Show_Hand("final" + hand_tracker);
            }
            else {} 
            dealerHand.Show_Hand("final", "show");
            if (!multiple_hands)
            {
                std::cout << std::endl << "This hand is a push. " << playerHand.player.display_name << " nets " << playerHand.player.display_net << " this hand." << std::endl;
            }
            else if (multiple_hands)
            {
                std::cout << std::endl << "Hand " << std::to_string(currentHandCounter) << " is a push. " << playerHand.player.display_name << " nets " << playerHand.player.display_net
                << " for hand " << std::to_string(currentHandCounter) << "." << std::endl << std::endl;
            }
            else {}
        }
        else if (dealerHand.player.cards_total > playerHand.player.cards_total && dealerHand.player.cards_total <= 21)
        {
            playerHand.Update_Bank("L", playerHand, playerHand.player.wager);
            
            if (!multiple_hands)
            {
                std::cout << dealerHand.player.display_name << " has a greater final value of " << dealerHand.player.display_cards_total << " compared to "
                << playerHand.player.display_name << "'s final value of " << playerHand.player.display_cards_total << "." << std::endl; 
                std::cout << std::endl << "The final hands of each player are:" << std::endl; 
                playerHand.Show_Hand("final");
            }
            else if (multiple_hands)
            {
                std::cout << dealerHand.player.display_name << " has a greater final value of " << dealerHand.player.display_cards_total << " for hand " << std::to_string(currentHandCounter)
                << " compared to " << playerHand.player.display_name << "'s final value of " << playerHand.player.display_cards_total << "." << std::endl; 
                std::cout << std::endl << "The final hands of each player for hand " << std::to_string(currentHandCounter) << " are:" << std::endl; 
                playerHand.Show_Hand("final" + hand_tracker);
            }
            else {}
            dealerHand.Show_Hand("final", "show");
            if (!multiple_hands)
            {
                std::cout << std::endl << playerHand.player.display_name << " loses the current hand. " << playerHand.player.display_name << " nets " << playerHand.player.display_net << " this hand." << std::endl;
            }
            else if (multiple_hands)
            {
                std::cout << std::endl << playerHand.player.display_name << " loses hand " << std::to_string(currentHandCounter) << ". " << playerHand.player.display_name << " nets " << playerHand.player.display_net
                << " for hand " << std::to_string(currentHandCounter) << "." << std::endl << std::endl;
            }
            else {}
        }
        else if (dealerHand.player.cards_total < playerHand.player.cards_total)
        {
            playerHand.Update_Bank("W", playerHand, playerHand.player.wager);
            
            if (!multiple_hands)
            {
                std::cout << playerHand.player.display_name << " has a greater final value of " << playerHand.player.display_cards_total << " compared to "
                << dealerHand.player.display_name << "'s final value of " << dealerHand.player.display_cards_total << "." << std::endl; 
                std::cout << std::endl << "The final hands of each player are:" << std::endl; 
                playerHand.Show_Hand("final");
            }
            else if (multiple_hands)
            {
                std::cout << playerHand.player.display_name << " has a greater final value of " << playerHand.player.display_cards_total << " for hand " << std::to_string(currentHandCounter)
                << " compared to " << dealerHand.player.display_name << "'s final value of " << dealerHand.player.display_cards_total << "." << std::endl; 
                std::cout << std::endl << "The final hands of each player for hand " << std::to_string(currentHandCounter) << " are:" << std::endl; 
                playerHand.Show_Hand("final" + hand_tracker);
            }
            else {}
            dealerHand.Show_Hand("final", "show");
            if (!multiple_hands)
            {
                std::cout << std::endl << playerHand.player.display_name << " wins the current hand. " << playerHand.player.display_name << " nets " << playerHand.player.display_net
                << " this hand." << std::endl;
            }
            else if (multiple_hands)
            {
                std::cout << std::endl << playerHand.player.display_name << " wins hand " << std::to_string(currentHandCounter) << ". " << playerHand.player.display_name << " nets " << playerHand.player.display_net
                << " for hand " << std::to_string(currentHandCounter) << "." << std::endl << std::endl;
            }
            else {}
        }
        else if (dealerHand.player.cards_total > 21)
        {
            playerHand.Update_Bank("W", playerHand, playerHand.player.wager);
            
            if (!multiple_hands)
            {
                std::cout << dealerHand.player.display_name << " has busted with a final value of " << dealerHand.player.display_cards_total << "." << std::endl; 
                std::cout << std::endl << "The final hands of each player for the current hand are:" << std::endl; 
                playerHand.Show_Hand("final");
            }
            else if (multiple_hands)
            {
                std::cout << dealerHand.player.display_name << " has busted with a final value of " << dealerHand.player.display_cards_total << "." << std::endl; 
                std::cout << std::endl << "The final hands of each player for hand " << std::to_string(currentHandCounter) << " are:" << std::endl; 
                playerHand.Show_Hand("final" + hand_tracker);
            }
            else {}
            dealerHand.Show_Hand("final", "show");
            if (!multiple_hands)
            {
                std::cout << std::endl << playerHand.player.display_name << " wins the current hand. " << playerHand.player.display_name << " nets " << playerHand.player.display_net << " this hand." << std::endl;
            }
            else if (multiple_hands)
            {
                std::cout << std::endl << playerHand.player.display_name << " wins hand " << std::to_string(currentHandCounter) << ". " << playerHand.player.display_name << " nets " << playerHand.player.display_net
                << " for hand " << std::to_string(currentHandCounter) << "." << std::endl << std::endl;
            }
            else {}
        }
        else {}
    }
    else if (playerHand.player.cards_total > 21)
    {
        playerHand.Update_Bank("L", playerHand, playerHand.player.wager);
        
        if (!multiple_hands)
        {
            std::cout << playerHand.player.display_name << " has busted with a final value of " << playerHand.player.display_cards_total << "." << std::endl; 
            std::cout << std::endl << "The final hands of each player for the current hand are:" << std::endl; 
            playerHand.Show_Hand("final");
        }
        else if (multiple_hands)
        {
            std::cout << playerHand.player.display_name << " has busted with a final value of " << playerHand.player.display_cards_total << " for hand " << std::to_string(currentHandCounter) << "." << std::endl; 
            std::cout << std::endl << "The final hands of each player for hand " << std::to_string(currentHandCounter) << " are:" << std::endl; 
            playerHand.Show_Hand("final" + hand_tracker);
        }
        else {}
        dealerHand.Show_Hand("final", "show");
        if (!multiple_hands)
        {
            std::cout << std::endl << playerHand.player.display_name << " loses the current hand. " << playerHand.player.display_name << " nets " << playerHand.player.display_net << " this hand." << std::endl;
        }
        else if (multiple_hands)
        {
            std::cout << std::endl << playerHand.player.display_name << " loses hand " << std::to_string(currentHandCounter) << ". " << playerHand.player.display_name << " nets " << playerHand.player.display_net
            << " for hand " << std::to_string(currentHandCounter) << "." << std::endl << std::endl;
        }
        else {}
    }
    else {}
    update_stats(playerHand);
    return std::make_tuple(playerHand, dealerHand, shoe);
}
// Game Logic Method
std::tuple<Hand, Hand, Shoe> game_logic(Hand& playerHand, Hand& dealerHand, Shoe& shoe) {
    auto showing_ace = dealer_showing_ace(playerHand, dealerHand, shoe);
    playerHand = std::get<0>(showing_ace);
    dealerHand = std::get<1>(showing_ace);
    shoe = std::get<2>(showing_ace);
    bool showing_ace_cont = std::get<3>(showing_ace);
    if (showing_ace_cont) 
    {
        // Player same rank check
        auto same_rank = player_same_rank(playerHand, dealerHand, shoe);
        std::vector<Hand> sr_hands = std::get<0>(same_rank);
        playerHand = std::get<1>(same_rank);
        dealerHand = std::get<2>(same_rank);
        shoe = std::get<3>(same_rank);
        int sr_hand_count = std::get<4>(same_rank);
        sr_hand_count %= sr_hand_count;
        // Player hand logic check
        std::vector<Hand> phl_hands;
        for (Hand& current_hand : sr_hands) 
        {
            sr_hand_count++;
            auto hand_logic = player_hand_logic(current_hand, dealerHand, playerHand, shoe, sr_hand_count);
            phl_hands.insert(phl_hands.begin(), std::get<0>(hand_logic));
            dealerHand = std::get<1>(hand_logic);
            playerHand = std::get<2>(hand_logic);
            shoe = std::get<3>(hand_logic);
        }
        std::reverse(phl_hands.begin(), phl_hands.end());
        // Dealer hand logic
        auto dealerHand_logic = dealer_hand_logic(phl_hands, dealerHand, shoe);
        dealerHand = std::get<0>(dealerHand_logic);
        shoe = std::get<1>(dealerHand_logic);
        // Hand comparison logic
        std::vector<Hand> hcl_hands;
        int playerHand_count = phl_hands.size();
        int currentHand_counter = 1;
        for (Hand& current_hand : phl_hands)
        {
            current_hand.Copy_Variables(playerHand);
            auto comparison_logic = hand_comparison(current_hand, dealerHand, shoe, playerHand_count, currentHand_counter);
            playerHand = std::get<0>(comparison_logic);
            dealerHand = std::get<1>(comparison_logic);
            shoe = std::get<2>(comparison_logic);
            hcl_hands.insert(hcl_hands.begin(), std::get<0>(comparison_logic));
            currentHand_counter++;
        }
        std::reverse(hcl_hands.begin(), hcl_hands.end());
        for (Hand& current_hand : hcl_hands) {
            current_hand.Reset("HandOver");
        }
    }
    else if (!showing_ace_cont) {}
    else {}
    return std::make_tuple(playerHand, dealerHand, shoe);
}
// Play game
void play_game()
{
    // Create Objects
    Shoe gameShoe;
    Hand playerHand;
    Hand dealerHand;
    // Set names of players
    dealerHand.player.name = "Dealer";
    playerHand.Name();
    // Take in Bank deposit of users
    playerHand.Deposit();
    // Create Shoe
    gameShoe.Deck_Count();
    gameShoe.Create_Shoe();
    gameShoe.Shuffle();
    while (gameShoe.deck.cards.size() >= 13 && playerHand.player.bank_total > 0)
    {
        auto gameLogic_result = game_logic(playerHand, dealerHand, gameShoe);
        playerHand = std::get<0>(gameLogic_result);
        dealerHand = std::get<1>(gameLogic_result);
        gameShoe = std::get<2>(gameLogic_result);
        bool continue_playing = false;
        playerHand.Reset("HandOver");
        dealerHand.Reset("HandOver");
        if (playerHand.player.bank_total > 0)
        {
            char cont_playing_input;
            while (true)
            {
                std::cout << std::endl << "Would you like to continue playing? (y/n): ";
                std::cin >> cont_playing_input;
                if (cont_playing_input == 'y')
                {
                    if (gameShoe.deck.cards.size() >= 13)
                    {
                        std::cout << std::endl << gameShoe.deck.cards.size() << " cards left in shoe. " << std::endl;
                        std::cout << std::endl << "Dealing new hands." << std::endl; time_sleep(5000);
                        clear_terminal();
                        break;
                    }
                    else if (gameShoe.deck.cards.size() < 13)
                    {
                        std::cout << std::endl << gameShoe.deck.cards.size() << " cards left in shoe. " << std::endl;
                        std::cout << std::endl << "Shuffling a new shoe." << std::endl;
                        gameShoe.deck.cards.clear();
                        gameShoe.Create_Shoe();
                        gameShoe.Shuffle(); time_sleep(5000);
                        clear_terminal();
                        break;
                    }
                    else
                    {
                        break;
                    }
                }
                else if (cont_playing_input == 'n')
                {
                    continue_playing = false;
                    std::cout << std::endl << playerHand.player.display_name << " has chosen to quit playing. Final bank total: " << playerHand.player.display_bank_total << std::endl;
                    std::cout << std::endl << "Thank you for playing." << std::endl; time_sleep(5000);
                    clear_terminal();
                    break;
                }
                else
                {
                    continue;
                }
            }
            if (cont_playing_input == 'y')
            {
                continue_playing = true;
            }
            else if (cont_playing_input == 'n')
            {
                continue_playing = false;
            }
            else {}
        }
        else if (playerHand.player.bank_total == 0)
        {
            std::cout << std::endl << playerHand.player.name << " has run out of currency in their bank. " << std::endl;
            char currency_continue;
            while (true)
            {
                std::cout << std::endl << "Would you like to deposit more currency into your bank? (y/n): ";
                std::cin >> currency_continue;
                if (currency_continue == 'y')
                {
                    playerHand.Deposit(); time_sleep(5000);
                    clear_terminal();
                    break;
                }
                else if (currency_continue == 'n')
                {
                    std::cout << std::endl << playerHand.player.name << " has ran out of currency and has chosen to " << "not deposit more currency into their bank. Game over." << std::endl;
                    std::cout << std::endl << "Thank you for playing." << std::endl; time_sleep(5000);
                    clear_terminal();
                    break;
                }
                else
                {
                    continue;
                }
            }
            if (currency_continue == 'y')
            {
                continue_playing = true;
            }
            else if (currency_continue == 'n')
            {
                continue_playing = false;
            }
            else {}
        }
        else {}
        if (!continue_playing)
        {
            break;
        }
        else if (continue_playing)
        {
            continue;
        }
        else {}
    }
    csv_stats(playerHand);
}